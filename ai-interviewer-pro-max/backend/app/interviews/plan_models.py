"""
Interview Plan Models

SQLAlchemy models for interview plan storage.
Plans are generated from resume + ATS analysis and linked to interview sessions.
"""

from sqlalchemy import Column, String, Text, Integer, DateTime, JSON, ForeignKey, Boolean
from datetime import datetime
import uuid

from app.db.base import Base


class InterviewPlan(Base):
    """
    Interview Plan model.
    
    Stores the personalized interview plan generated from:
    - Resume text
    - ATS analysis results
    - Target job role
    
    Per requirements:
    - Plans are user-scoped
    - Plans are reusable and auditable
    - Plans link to interview sessions
    """
    
    __tablename__ = "interview_plans"
    
    # Primary key
    id = Column(String(36), primary_key=True, default=lambda: str(uuid.uuid4()))
    
    # User and Resume relationships
    user_id = Column(String(36), nullable=False, index=True)
    resume_id = Column(String(36), nullable=False, index=True)
    ats_analysis_id = Column(String(36), nullable=True)  # Optional ATS analysis link
    
    # Target role
    target_role = Column(String(200), nullable=False)
    target_role_description = Column(Text, nullable=True)
    
    # ===========================================
    # PLAN CONFIGURATION
    # ===========================================
    
    # Session type: technical, behavioral, mixed, hr, etc.
    session_type = Column(String(50), default="mixed")
    
    # Difficulty: easy, medium, hard, expert
    difficulty_level = Column(String(20), default="medium")
    
    # Total questions
    total_questions = Column(Integer, default=10)
    
    # Estimated duration in minutes
    estimated_duration_minutes = Column(Integer, default=30)
    
    # ===========================================
    # QUESTION BREAKDOWN
    # ===========================================
    
    # Question count by category
    dsa_question_count = Column(Integer, default=0)  # DSA/Algorithm questions
    technical_question_count = Column(Integer, default=0)
    behavioral_question_count = Column(Integer, default=0)
    hr_question_count = Column(Integer, default=0)
    situational_question_count = Column(Integer, default=0)
    
    # Question categories with details
    # [{category, count, difficulty, focus_area, rationale}]
    question_categories = Column(JSON, default=list)
    
    # ===========================================
    # FOCUS AREAS (from ATS analysis)
    # ===========================================
    
    # Areas to probe deeply (strengths)
    strength_focus_areas = Column(JSON, default=list)  # [{area, reason, question_count}]
    
    # Areas to test more (weaknesses/gaps)
    weakness_focus_areas = Column(JSON, default=list)  # [{area, reason, question_count}]
    
    # Skills to be tested
    skills_to_test = Column(JSON, default=list)  # [skill_name]
    
    # ===========================================
    # GENERATED QUESTIONS (pre-generated)
    # ===========================================
    
    # Full question list (generated by Gemini)
    # [{id, text, type, category, difficulty, time_limit, expected_topics, scoring_rubric}]
    questions = Column(JSON, default=list)
    
    # ===========================================
    # PLAN SUMMARY
    # ===========================================
    
    # Human-readable plan summary
    summary = Column(Text, nullable=True)
    
    # Rationale for plan decisions
    rationale = Column(Text, nullable=True)
    
    # ===========================================
    # COMPANY MODE
    # ===========================================
    
    # Company interview mode (faang, startup, service, product, custom)
    company_mode = Column(String(50), nullable=True)
    
    # Company mode details
    company_info = Column(JSON, nullable=True)
    
    # ===========================================
    # METADATA
    # ===========================================
    
    # Plan generation source
    generation_source = Column(String(50), default="mock")  # mock or gemini
    generation_model = Column(String(100), nullable=True)
    
    # Processing time
    processing_time_ms = Column(Integer, nullable=True)
    
    # Plan status
    status = Column(String(20), default="draft")  # draft, ready, used, expired
    
    # Whether plan has been used for an interview
    # CRITICAL: nullable=False ensures is_used is NEVER NULL
    is_used = Column(Boolean, default=False, nullable=False, server_default="0")
    used_for_session_id = Column(String(36), nullable=True)
    
    # Timestamps
    created_at = Column(DateTime, default=datetime.utcnow, nullable=False)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow, nullable=False)
    
    def __repr__(self):
        return f"<InterviewPlan(id={self.id}, role={self.target_role}, questions={self.total_questions})>"
    
    def to_dict(self) -> dict:
        """Convert to dictionary for API response.
        
        SAFETY: All values are explicitly cast to handle NULL from SQLite.
        """
        return {
            "id": self.id,
            "user_id": self.user_id,
            "resume_id": self.resume_id,
            "ats_analysis_id": self.ats_analysis_id,
            "target_role": self.target_role or "",
            "session_type": self.session_type or "mixed",
            "difficulty_level": self.difficulty_level or "medium",
            "total_questions": self.total_questions or 10,
            "estimated_duration_minutes": self.estimated_duration_minutes or 30,
            "breakdown": {
                "dsa": self.dsa_question_count or 0,
                "technical": self.technical_question_count or 0,
                "behavioral": self.behavioral_question_count or 0,
                "hr": self.hr_question_count or 0,
                "situational": self.situational_question_count or 0,
            },
            "question_categories": self.question_categories or [],
            "strength_focus_areas": self.strength_focus_areas or [],
            "weakness_focus_areas": self.weakness_focus_areas or [],
            "skills_to_test": self.skills_to_test or [],
            "summary": self.summary or "",
            "rationale": self.rationale or "",
            "company_mode": self.company_mode,  # OK to be None
            "company_info": self.company_info,  # OK to be None
            "generation_source": self.generation_source or "mock",
            "status": self.status or "draft",
            # CRITICAL: is_used MUST be a boolean, never None
            "is_used": bool(self.is_used) if self.is_used is not None else False,
            "created_at": self.created_at.isoformat() if self.created_at else None,
        }
    
    def to_preview_dict(self) -> dict:
        """Convert to preview dictionary (without full questions).
        
        SAFETY: All values are explicitly cast to handle NULL from SQLite.
        """
        return {
            "id": self.id,
            "target_role": self.target_role or "",
            "session_type": self.session_type or "mixed",
            "difficulty_level": self.difficulty_level or "medium",
            "total_questions": self.total_questions or 10,
            "estimated_duration_minutes": self.estimated_duration_minutes or 30,
            "breakdown": {
                "dsa": self.dsa_question_count or 0,
                "technical": self.technical_question_count or 0,
                "behavioral": self.behavioral_question_count or 0,
                "hr": self.hr_question_count or 0,
                "situational": self.situational_question_count or 0,
            },
            "summary": self.summary or "",
            "company_mode": self.company_mode,  # OK to be None
            "company_info": self.company_info,  # OK to be None
            "status": self.status or "draft",
            "is_used": bool(self.is_used) if self.is_used is not None else False,
            "created_at": self.created_at.isoformat() if self.created_at else None,
        }
    
    def get_questions_list(self) -> list:
        """Get the list of questions."""
        return self.questions or []
